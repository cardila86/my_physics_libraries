__author__ = "Carlos Ardila Gutierrez"
__maintainer__ = "Carlos Ardila Gutierrez"
__email__ = "carlos2248383@correo.uis.edu.co"
__date__ = "January 06, 2025"

import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import os
import numpy as np
import pandas as pd


class plottingTools:
    '''
    Class to plot physics graph.
    ==========
    Parameters
    ==========
        - property:
        - 
        -

    ======
    Return
    ======
        None.
    ======
    Tested compatibility
    ======
        - matplotlib 3.10.0
        - numpy 2.2.1
        - pyqt5
    '''
    def __init__(self, E_zero_color='gray', E_zero_linewidth=0.2, E_zero_linestyle='--',
                k_color='gray', k_linewidth=0.2, k_linestyle='-',
                main_linewidth=1.3, main_linestyle='-'):
        self.E_zero_color=E_zero_color
        self.E_zero_linewidth=E_zero_linewidth
        self.E_zero_linestyle=E_zero_linestyle
        self.k_color=k_color
        self.k_linewidth=k_linewidth
        self.k_linestyle=k_linestyle
        self.main_linewidth=main_linewidth
        self.main_linestyle=main_linestyle

    def _read_bands_vaspkit(self, path_read, fermi_vaspkit=False, klabels_bool=False, kticks_bool=False):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_band = path_read + '/REFORMATTED_BAND.dat'
        if os.path.isfile(path_band):
            data = np.loadtxt(path_band, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
        # ------- band structure files splitted by spin --------
        else:
            path_band_dw = path_read + '/REFORMATTED_BAND_DW.dat'
            path_band_up = path_read + '/REFORMATTED_BAND_UP.dat'
            data = np.loadtxt(path_band_dw, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
            data = np.loadtxt(path_band_up, skiprows=1)
            data = data.transpose()
            E = np.append(E, data[1:], axis=0)
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi_vaspkit:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            for i in range(len(E)):
                E[i] += Efermi
        # ------- kticks & klabels --------
        if klabels_bool or kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
            kticks = np.array(kticks)
        # ------- return data --------
        if klabels_bool and kticks_bool:
            return kpoints, E, klabel, kticks
        elif klabels_bool and not kticks_bool:
            return kpoints, E, klabel
        elif not klabels_bool and kticks_bool:
            return kpoints, E, kticks
        else:
            return kpoints, E

    def _read_bands_vaspkit_projected(self, path_read, root, orbs, fermi_vaspkit=False, klabels_bool=False, kticks_bool=False):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_band = path_read + '/REFORMATTED_BAND.dat'
        if os.path.isfile(path_band):
            data = np.loadtxt(path_band, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
        # ------- band structure files splitted by spin --------
        else:
            path_band_dw = path_read + '/REFORMATTED_BAND_DW.dat'
            path_band_up = path_read + '/REFORMATTED_BAND_UP.dat'
            data = np.loadtxt(path_band_dw, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
            data = np.loadtxt(path_band_up, skiprows=1)
            data = data.transpose()
            E = np.append(E, data[1:], axis=0)        
        # ------ single band structure file for both spin ------
        path_projection =  path_read + '/' + root
        if os.path.isfile(path_projection):
            data = np.loadtxt(path_projection, skiprows=3)
            data = data.transpose()
            kpoints_check = data[0]
            bands = data[1]
            orbs_projection = data[2:]
            for i in range(len(kpoints_check)-1):
                if kpoints_check[i+1]<kpoints_check[i]:
                    npoints = i
                    break
            # ======= check that projection and bands match =======
            assert npoints == len(kpoints), 'ERROR: The number of kpoints in the bands and the projection file do not match.'
            # =====================================================
            orbs_projection_list = []
            for i in orbs:
                l = [orbs_projection[i][npoints*j:npoints*(j+1)] for j in range(len(E))]
                orbs_projection_list.append(l)
        # ------- band structure files splitted by spin --------
        else:
            print(f'ERROR: path \'{path_band}\' not found')
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi_vaspkit:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            for i in range(len(E)):
                E[i] += Efermi
        # ------- kticks & klabels --------
        if klabels_bool or kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
            kticks = np.array(kticks)
        # ------- return data --------
        if klabels_bool and kticks_bool:
            return kpoints, E, orbs_projection_list, klabel, kticks
        elif klabels_bool and not kticks_bool:
            return kpoints, E, orbs_projection_list, klabel
        elif not klabels_bool and kticks_bool:
            return kpoints, E, orbs_projection_list, kticks
        else:
            return kpoints, E, orbs_projection_list

    def _read_bands_p4vasp_projected(self, path_read, root, norbs=None, klabels_bool=False, kticks_bool=False):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_projection =  path_read + '/' + root

        # ----------- separate bands and projections -----------
        nlines, nkpoints, nbands = 0, 0, 0
        with open(path_projection) as dataFile:
            for data in dataFile:
                if len(data.split())==3:

                    break
                elif len(data.split())==0:
                    if nkpoints==0:
                        nkpoints = nlines
                    nbands+=1
                    nlines+=1
                else:
                    nlines+=1
        kpoints, bands, bands_projection = [], [], []
        if os.path.isfile(path_projection):
            # -------- bands witoout projections --------
            # data_bands = np.loadtxt(path_projection, usecols=(0,1))
            # data_bands = data_bands.transpose()
            # kpoints = data_bands[0]
            # bands = data_bands[1]
            # kpoints = kpoints[:nkpoints]*2*np.pi
            # bands = [bands[nkpoints*j:nkpoints*(j+1)] for j in range(len(bands)//nkpoints)]
    
            data_projection = np.loadtxt(path_projection, usecols=(0,1,2), skiprows=nlines)
            data_projection = data_projection.transpose()
            kpoints = data_projection[0][:nkpoints]*2*np.pi
            bands = data_projection[1]
            projection = data_projection[2]
            bands = [bands[nkpoints*j:nkpoints*(j+1)] for j in range(nbands)]
            # ------ checks whether the bands are duplicated ------
            spin = False
            for i in range(len(bands)-1):
                if bands[i][0]>bands[i+1][0]:
                    spin = True
            n = 0
            for i in range((len(projection)//nkpoints)//nbands):
                bands_projection.append([projection[nkpoints*(j+nbands*i):nkpoints*(j+1+nbands*i)] for j in range(nbands)])
            # ======= check that projection and bands match =======
            for i in range(len(bands)):
                assert len(kpoints) == len(bands[i]), f'ERROR: The number of kpoints and the lenght of each band do not match. (1).'
            for i in range(len(bands_projection)):
                for j in range(len(bands_projection[i])):
                    assert len(kpoints) == len(bands_projection[i][j]), 'ERROR: The number of kpoints in the bands and the projection file do not match. (2)'
            # =====================================================
        else:
            print(f'ERROR: path \'{path_projection}\' not found')
        # ------- kticks & klabels --------
        if klabels_bool or kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
            kticks = np.array(kticks)
        # ------- return data --------
        if klabels_bool and kticks_bool:
            return kpoints, bands, bands_projection, klabel, kticks
        elif klabels_bool and not kticks_bool:
            return kpoints, bands, bands_projection, klabel
        elif not klabels_bool and kticks_bool:
            return kpoints, bands, bands_projection, kticks
        else:
            return kpoints, bands, bands_projection

    def _read_PDOS_p4vasp_projected(self, path_read, root):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_projection =  path_read + '/' + root

        # ----------- separate bands and projections -----------
        nlines, nkpoints, nbands = 0, 0, 0

        if os.path.isfile(path_projection):
            # -------- bands witoout projections --------
            # data_bands = np.loadtxt(path_projection, usecols=(0,1))
            # data_bands = data_bands.transpose()
            # kpoints = data_bands[0]
            # bands = data_bands[1]
            # kpoints = kpoints[:nkpoints]*2*np.pi
            # bands = [bands[nkpoints*j:nkpoints*(j+1)] for j in range(len(bands)//nkpoints)]
    
            data_projection = np.loadtxt(path_projection, usecols=(0,1))
            data_projection = data_projection.transpose()
            E = data_projection[0]
            PDOS = data_projection[1]
                
            npoints = 0
            for i in range(len(E)-1):
                if E[i+1]<E[i]:
                    npoints = i+1
                    break
            E = E[:npoints]
            PDOS = [PDOS[npoints*j:npoints*(j+1)] for j in range(len(PDOS)//npoints)]

        return E, PDOS

    def _read_bands_wannier(self, path_read, klabels_bool=False, kticks_bool=False):
        '''
        Reads the band structure generated by wannier90.
        '''
        # ------- Define paths --------
        path_band = path_read+'_band.dat'
        path_label_info = path_read+'_band.labelinfo.dat'
        # ------- band structure in 2 columns separated by empty rows --------
        data = np.loadtxt(path_band, skiprows=0)
        data = data.transpose()
        kpoints, bands = data[0], data[1]
        for i in range(len(kpoints)-1):
            if kpoints[i+1]<kpoints[i]:
                npoints = i+1
                kpoints = kpoints[:npoints]
                break
        E = [bands[npoints*i:npoints*(i+1)] for i in range(len(bands)//npoints)]
        # ------- kticks & klabels --------
        if klabels_bool or kticks_bool:
            knames, kticks = [], []
            with open(path_label_info) as dataFile:
                idx = -10  # Numero lejos del primer idx
                for data in dataFile:
                    name = data.split()[0]
                    tick = eval(data.split()[2])

                    # Mira si los ticks estan uno al lado de otro.
                    # En caso tal, los junta en uno solo
                    if abs(eval(data.split()[1])-idx)<2:
                        knames[-1] = knames[-1]+'|'+name
                    else:
                        knames.append(name)
                        kticks.append(tick)

                    idx = eval(data.split()[1])
        # ------- return data --------
        if klabels_bool and kticks_bool:
            return kpoints, E, knames, kticks
        elif klabels_bool and not kticks_bool:
            return kpoints, E, knames
        elif not klabels_bool and kticks_bool:
            return kpoints, E, kticks
        else:
            return kpoints, E

    def _read_nodes_wannierTools(self, path_read):
        '''
        Reads all the nodes generated by wannierTools_2.5.1.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------------ reading of the nodes ----------------
        path_nodes = path_read + '/Nodes.dat'
        if os.path.isfile(path_nodes):
            data = np.loadtxt(path_nodes)
            data = data.transpose()
            
            kvec_car= np.array(data[0:3]).transpose()
            gap     = np.array(data[3])
            E       = np.array(data[4])
            kvec_dir= np.array(data[5:]).transpose()
        # ------- path does not match with any file --------
        else:
            print(f'ERROR: path \'{path_nodes}\' not found')
        
        return kvec_car, gap, E, kvec_dir

    def _read_LDoS_vaspkit(self, path_read, fermi_vaspkit=False):
        '''
        Reads the local density of states generated by vaspkit1.3.5.
        '''        
        if os.path.isfile(path_read):
            data = np.loadtxt(path_read)
            data = data.transpose()
            # IMPORTANTE: Parece que el usar este metodo de sort no incrementa
            # tanto el tiempo, pero podriamos probar usando el sort de numpy.
            data = list(zip(*sorted(zip(*data))))
            data = np.array(data)
            E = data[0]
            orbitals = data[1:-1]
            total = data[-1]
            # 
            with open(path_read) as f:
                orbitals_labels = f.readline()
                orbitals_labels = orbitals_labels.split()[1:-1]
        else:
            print(f'File {path_read} not found.')
            exit()
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi_vaspkit:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            E += Efermi
        
        
        return E, orbitals_labels, orbitals, total
    
    def _read_LDoS_p4vasp(self, path_read, fermi_vaspkit=False):
        '''
        Reads the local density of states generated by p4vasp.
        '''        

        # ----------- separate bands and projections -----------
        nlines, nkpoints, nbands = 0, 0, 0

        if os.path.isfile(path_read):
            # -------- bands witoout projections --------
            # data_bands = np.loadtxt(path_projection, usecols=(0,1))
            # data_bands = data_bands.transpose()
            # kpoints = data_bands[0]
            # bands = data_bands[1]
            # kpoints = kpoints[:nkpoints]*2*np.pi
            # bands = [bands[nkpoints*j:nkpoints*(j+1)] for j in range(len(bands)//nkpoints)]
    
            data_projection = np.loadtxt(path_read, usecols=(0,1))
            data_projection = data_projection.transpose()
            E = data_projection[0]
            PDOS = data_projection[1]
            npoints = 0
            for i in range(len(E)-1):
                if E[i+1]<E[i]:
                    npoints = i+1
                    break
            E = E[:npoints]
            PDOS = [PDOS[npoints*j:npoints*(j+1)] for j in range(len(PDOS)//npoints)]
            DOS  = PDOS[0]
            PDOS = PDOS[1:]
        
            return E, PDOS, DOS
        else:
            print(f'ERROR: File \'{path_read}\' not found.')

    def separate_nodes(self, path_read, kpath=None, Elimit=None, ktol=0.001, savefile=None):
        # -------------- reads info --------------
        kvec_car, gap, E, kvec_dir = self._read_nodes_wannierTools(path_read)
        # ------ separates nodes by location and energy ------
        nodes_separated = []
        E_separeted     = []
        Egap_separeted  = []
        path_separated  = []
        if kpath is not None:
            for i in range(len(kpath)-1):
                nodes_separated.append([])
                E_separeted.append([])
                Egap_separeted.append([])

                symm_point_1 = kpath[i]
                symm_point_2 = kpath[i+1]
                vec_path = np.array(symm_point_2) - np.array(symm_point_1)
                for j in range(len(kvec_dir)):
                    vec_a = np.array(kvec_dir[j])-np.array(symm_point_1)
                    distance = np.linalg.norm(np.cross(vec_path, vec_a))/np.linalg.norm(vec_path)
                    if distance<ktol:
                        if Elimit is not None:
                            if Elimit[0]<=E[j]<=Elimit[1]:
                                nodes_separated[i].append(kvec_dir[j])
                                E_separeted[i].append(E[j])
                                Egap_separeted[i].append(gap[j])
                                path_separated.append(i+1)
                        elif Elimit is None:
                            nodes_separated[i].append(kvec_dir[j])
                            E_separeted[i].append(E[j])
                            Egap_separeted[i].append(gap[j])
                            path_separated.append(i+1)
        else:
            if Elimit is not None:
                for i in range(len(E)):
                    if Elimit[0]<=E[i]<=Elimit[1]:
                        nodes_separated.append(kvec_dir[i])
                        E_separeted.append(E[i])
                        Egap_separeted.append(gap[i])
                        path_separated.append(0)
            else:
                nodes_separated = kvec_dir
                E_separeted = E
                Egap_separeted = gap
                path_separated = np.zeros(len(E))
        # -----------


        if savefile is not None:
            knodes_saveformat   = []
            E_saveformat        = []
            Egap_saveformat     = []
            if kpath is not None:
                for i in range(len(nodes_separated)):
                    for j in range(len(nodes_separated[i])):
                        knodes_saveformat.append(nodes_separated[i][j])
                        E_saveformat.append(E_separeted[i][j])
                        Egap_saveformat.append(Egap_separeted[i][j])
            else:
                knodes_saveformat   = nodes_separated
                E_saveformat        = E_separeted
                Egap_saveformat     = Egap_separeted
            knodes_saveformat = np.array(knodes_saveformat)
            knodes_saveformat = knodes_saveformat.transpose()
            if len(knodes_saveformat)==0:
                knodes_saveformat = [[], [], []]

            doc = np.column_stack([path_separated, knodes_saveformat[0]])
            doc = np.column_stack([doc, knodes_saveformat[1]])
            doc = np.column_stack([doc, knodes_saveformat[2]])
            doc = np.column_stack([doc, E_saveformat])
            doc = np.column_stack([doc, Egap_saveformat])
            np.savetxt(savefile, doc, header='path      k1           k2           k3           E           Egap', 
                       fmt=['%4d', ' % 2.8f', ' % 2.8f', ' % 2.8f', ' % 2.8f', ' % 2.8f'])

        return nodes_separated, E_separeted, Egap_separeted, path_separated

    def _read_curvature_wannier90(self, path_read, axis):
        data = np.loadtxt(path_read + '/wannier90-curv.dat')
        kpoints=data[:,0]
        if axis == 0:
            curv=np.zeros(len(kpoints))
            for i in [1, 2, 3]:
                curv+=np.array(data[:,i])**2
            curv = np.sqrt(curv)
            curv = curv.tolist()
        else:
            curv=data[:,axis]

        return kpoints, curv

    def __plot_bands_vaspkit_break(self,
                            path_read,
                            E_limit=[-1, 1],
                            E_zero=0,
                            E_vaspkit=False,
                            klabels= None,
                            kticks=None,
                            kbreaks=None,
                            label=None,
                            color='k',
                            ax=None,
                            show=False,
                            savefile=None):
        pass

    def plot_bands_pyprocar(self,   
                                   path_read,
                                   atoms=None,
                                   orbitals=None,
                                   spins=None,
                                   mode='plain',
                                   E_limit=[-1, 1],
                                   E_zero=0,
                                   klabels= None,
                                   kticks=None,
                                   cmap='jet',
                                   cbar=False,
                                   ax=None,
                                   show=False,
                                   savefile=None,
                                   export_data=None):
        '''
        Uses pyprocar 6.3.2
        '''
        
        import pyprocar

        # if ax is not None:
        #     fig = ax.get_figure()
        #     ax_len = len(fig.get_axes())

        bands = pyprocar.bandsplot(
                code='vasp', dirname=path_read, mode=mode,
                fermi=E_zero, fermi_color = 'black', fermi_linestyle='dashed', fermi_linewidth=0.5,
                elimit=E_limit, cmap=cmap, linestyle=['solid', 'solid'], linewidth=[self.main_linewidth, self.main_linewidth],
                kticks=kticks, knames=klabels,
                atoms=atoms, orbitals=orbitals, spins=spins,
                show=show, savefig=savefile, dpi=300, ax=ax, export_data_file=export_data)
        
        fig, ax = bands[0:2]

        # if not cbar:
        #     if abs(ax_len-len(fig.get_axes()))>0:
        #         fig.delaxes(fig.axes[-1])

        return fig, ax    

    def plot_bands(self,
                           path_read,
                           program='vaspkit',
                           root='wannier90',
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           color='k',
                           nbands=None,
                           ax=None,
                           show=False,
                           savefile=None):
        # ------------ ax, fig objects -----------
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.get_figure()
        # -------------- reads info --------------
        if program=='vaspkit':
            if klabels is None and kticks is None:
                kpoints, E, klabels, kticks = self._read_bands_vaspkit(path_read, fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=True)
            elif klabels is None and kticks is not None:
                kpoints, E, klabels = self._read_bands_vaspkit(path_read, fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=False)
            elif klabels is not None and kticks is None:
                kpoints, E, kticks = self._read_bands_vaspkit(path_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=True)
            else:
                kpoints, E = self._read_bands_vaspkit(path_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=False)
        elif program=='wannier90':
            path_read=path_read+'/'+root
            if klabels is None and kticks is None:
                kpoints, E, klabels, kticks = self._read_bands_wannier(path_read, klabels_bool=True, kticks_bool=True)
            elif klabels is None and kticks is not None:
                kpoints, E, klabels = self._read_bands_wannier(path_read, klabels_bool=True, kticks_bool=False)
            elif klabels is not None and kticks is None:
                kpoints, E, kticks = self._read_bands_wannier(path_read, klabels_bool=False, kticks_bool=True)
            else:
                kpoints, E = self._read_bands_wannier(path_read, klabels_bool=False, kticks_bool=False)
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ------------ discontinuities -----------
        if kbreaks is not None:
            for i in kbreaks:
                for j in range(len(kpoints)):
                    if j!=0 and abs(kpoints[j]-kticks[i])<abs(kpoints[j]-kpoints[j-1])/2: # Mira que este cerca a un ktick
                        for k in range(len(E)):
                            E[k][j] = np.nan
        # -------------- plot bands --------------
        if nbands is None:
            bands=E
        elif type(nbands) is int or type(nbands) is float:
            nbands = int(nbands)
            bands=E[0:nbands]
        elif type(nbands) is list:
            bands=[]
            for i in nbands:
                bands.append(E[int(i)])
        else:
            print('ERROR: nbands must be an integer, a float or a list of integers.\n'+
                  'a '+str(type(nbands))+' type was recieved. Please check inputs.') 
            exit()
        n = 0
        for band in bands:
            band-=E_zero
            if n==0 and label is not None:
                n+=1
                ax.plot(kpoints, band, c=color, linewidth=self.main_linewidth, linestyle=self.main_linestyle, label=label)
            else:
                ax.plot(kpoints, band, c=color, linewidth=self.main_linewidth, linestyle=self.main_linestyle)

        # ------------- set limits --------------
        bool_klabels = [i=='' for i in klabels]
        klabels_filtered = [i for i in klabels if i!='']
        if any(bool_klabels):
            if len(klabels_filtered)!=2:
                ind = klabels.index('')
                ax.set_xlim([0,kticks[ind-1]])
            elif len(klabels_filtered)==2:
                ind1 = klabels.index(klabels_filtered[0])
                ind2 = klabels.index(klabels_filtered[1])
                ax.set_xlim([kticks[ind1],kticks[ind2]])
        else:
            ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')

        # ------ output -------
        if label is not None:
            ax.legend()
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        
        return fig, ax

    def plot_nodes(self,
                    path_read,
                    E_limit=[-1, 1],
                    E_zero=0,
                    path_k=None,
                    klabels= None,
                    kticks=None,
                    kbreaks=None,
                    label=None,
                    color='k',
                    nbands=None,
                    ax=None,
                    show=False,
                    savefile=None):
        '''
        Plot nodes calculated by wannierTools and if wanted, their chirality.
        '''
        # ------------ ax, fig objects -----------
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.get_figure()
        # -------------- reads info --------------
        kvec_car, gap, E, kvec_dir = self._read_nodes_wannierTools(path_read)

    def plot_bands_projected_orbs(self,
                           path_read,
                           root='PBAND_Atom1.dat',
                           orbs=[0, 1, 2],
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           colors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                           nbands=None,
                           ax=None,
                           show=False,
                           savefile=None):
        '''
        This function allows for the plotting of the band structure projected
        over atomic orbitals. Procesing of the data is required to be done by
        vaspkit1.3.5.
        At the moment, it can only plot one atom or element projection at a time.
        ==========
        Para orbs, se puede graficar por conjunto de orbitales. Por ejemplo, 
        S y P sería [[0], [1, 2, 3]]... 
        '''
        # -------------- reads info --------------
        orbs_grouped = False
        orbs_read = []
        n = 0
        for orb in orbs:
            if type(orb) is not float and type(orb) is not int:
                orbs_grouped = True
                n += 1 
                for i in orb:
                    orbs_read.append(i)
            else:
                orbs_read.append(orb)
        assert n < 4, 'ERROR: At this moment, orbs input supports only 3 orbitals (grouped orbitals count as 1).'

        if klabels is None and kticks is None:
            kpoints, E, orbs_projection_list, klabels, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read,fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=True)
        elif klabels is None and kticks is not None:
            kpoints, E, orbs_projection_list, klabels = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=False)
        elif klabels is not None and kticks is None:
            kpoints, E, orbs_projection_list, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=True)
        else:
            kpoints, E, orbs_projection_list = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=False)

        # ------------ ax, fig objects -----------
        if ax is None and kbreaks is None:
            fig, ax = plt.subplots()
        elif ax is None and kbreaks is not None:
            num_ax = len(kbreaks)+1
            fig, ax = plt.subplots(num_ax)
        else:
            fig = ax.get_figure()
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ------- Order Projection and asign colors -------
        if orbs_grouped:
            orbs_grouped_list = []
            n_projection = 0
            for orb in orbs:
                if type(orb) is not float and type(orb) is not int:
                    orbs_sum = [np.zeros(len(orbs_projection_list[n_projection][0])) for _ in range(len(orbs_projection_list[n_projection]))]
                    for _ in range(len(orb)):
                        for band in range(len(orbs_sum)):
                            orbs_sum[band] += orbs_projection_list[n_projection][band]                  
                        n_projection += 1
                    orbs_grouped_list.append(orbs_sum)
                else:
                    orbs_grouped_list.append(orbs_projection_list[n_projection])
                    n_projection += 1
            orbs_projection_list = orbs_grouped_list
        else:
            pass
        assert len(orbs_projection_list)<4, 'ERROR: At this moment, orbs input supports only 3 orbitals.'
        
        orbs_colors = []
        for i in range(3):
            if len(orbs_colors)<len(orbs_projection_list):
                for j in range(len(orbs_projection_list[i])):
                    orbs_projection_list[i][j] = 1-orbs_projection_list[i][j]
                orbs_colors.append(orbs_projection_list[i])
            else:
                orbs_colors.append([np.ones(len(orbs_colors[0][0])) for _ in range(len(orbs_colors[0]))])
        # ----- change to arbitrary colors -----
        if colors!=[]:
            # change rgb into 0-1 scale
            for i in range(len(colors)):
                for j in range(len(colors[i])):
                    colors[i][j] = colors[i][j]/255
            # check that 3 colors are given
            assert len(colors)==3, 'ERROR: colors must be a list of 3 lists of 3 integers.'
            # assign colors
            new_orbs_colors = [[] for _ in range(len(orbs_colors[0]))]
            for i in range(len(orbs_colors[0])):
                for j in range(len(colors[0])):
                    new_orbs_colors[i].append(np.array(colors[0][j])*orbs_colors[0][i]+np.array(colors[1][j])*orbs_colors[1][i]+np.array(colors[2][j])*orbs_colors[2][i])
                    new_orbs_colors[i][j] = np.clip(new_orbs_colors[i][j], 0, 1)
                    # new_orbs_colors[i][j] = new_orbs_colors[i][j]/np.max(new_orbs_colors[i][j])
            orbs_colors = new_orbs_colors
        # -------------- isolates bands --------------
        if nbands is None:
            bands=E
        elif type(nbands) is int or type(nbands) is float:
            nbands = int(nbands)
            bands=E[0:nbands]
            new_colors = []
            for i in range(3):
                new_colors.append(orbs_colors[i][0:nbands])
            orbs_colors = new_colors
        elif type(nbands) is list:
            bands=[]
            new_colors = []
            for i in nbands:
                bands.append(E[int(i)])
            for i in range(3):
                for j in nbands:
                    new_colors.append(orbs_colors[i][int(j)])
            orbs_colors = new_colors
        else:
            print('ERROR: nbands must be an integer, a float or a list of integers.\n'+
                  'a '+str(type(nbands))+' type was recieved. Please check inputs.') 
            exit()
        # -------------- plot bands --------------
        for band, orbs_color in zip(bands, orbs_colors):
            band-=E_zero
            color_projection = np.column_stack([orbs_color[0], orbs_color[1], orbs_color[2]]) 
            # ---- create segments ----
            points = np.array([kpoints, band]).transpose().reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            lc = LineCollection(segments, colors=color_projection, linewidths=self.main_linewidth)
 
            ax.add_collection(lc)

        # n = 0
        # for i in range(len(bands)):
        #     band=bands[i]-E_zero
        #     color_projection = [orbs_colors[0][i], orbs_colors[1][i], orbs_colors[2][i]]
        #     color_projection = np.array(color_projection).transpose()
        #     if n==0 and label is not None:
        #         n+=1
        #         ax.scatter(kpoints, band, s=1, c=color_projection, linewidth=self.main_linewidth, linestyle=self.main_linestyle, label=label)
        #     else:
        #         ax.scatter(kpoints, band, s=1, c=color_projection,  linewidth=self.main_linewidth, linestyle=self.main_linestyle)

        # ------------- set limits --------------
        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')

        # ------ output -------
        if label is not None:
            ax.legend()
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        return fig, ax

    def plot_bands_projected_orbs_2(self,
                           path_read,
                           root='PBAND_Atom1.dat',
                           orbs=[0, 1, 2],
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           colors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                           nbands=None,
                           ax=None,
                           show=False,
                           savefile=None):
        '''
        This function allows for the plotting of the band structure projected
        over atomic orbitals. Procesing of the data is required to be done by
        vaspkit1.3.5.
        At the moment, it can only plot one atom or element projection at a time.
        ==========
        Para orbs, se puede graficar por conjunto de orbitales. Por ejemplo, 
        S y P sería [[0], [1, 2, 3]]... 
        '''
        # -------------- reads info --------------
        orbs_grouped = False
        orbs_read = []
        n = 0
        for orb in orbs:
            if type(orb) is not float and type(orb) is not int:
                orbs_grouped = True
                n += 1 
                for i in orb:
                    orbs_read.append(i)
            else:
                orbs_read.append(orb)
        assert n < 4, 'ERROR: At this moment, orbs input supports only 3 orbitals (grouped orbitals count as 1).'

        if klabels is None and kticks is None:
            kpoints, E, orbs_projection_list, klabels, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read,fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=True)
        elif klabels is None and kticks is not None:
            kpoints, E, orbs_projection_list, klabels = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=False)
        elif klabels is not None and kticks is None:
            kpoints, E, orbs_projection_list, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=True)
        else:
            kpoints, E, orbs_projection_list = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=False)

        # ------------ ax, fig objects -----------
        if ax is None and kbreaks is None:
            fig, ax = plt.subplots()
        elif ax is None and kbreaks is not None:
            num_ax = len(kbreaks)+1
            fig, ax = plt.subplots(num_ax)
        else:
            fig = ax.get_figure()
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ------- Order Projection and asign colors -------
        if orbs_grouped:
            orbs_grouped_list = []
            n_projection = 0
            for orb in orbs:
                if type(orb) is not float and type(orb) is not int:
                    orbs_sum = [np.zeros(len(orbs_projection_list[n_projection][0])) for _ in range(len(orbs_projection_list[n_projection]))]
                    for _ in range(len(orb)):
                        for band in range(len(orbs_sum)):
                            orbs_sum[band] += orbs_projection_list[n_projection][band]                  
                        n_projection += 1
                    orbs_grouped_list.append(orbs_sum)
                else:
                    orbs_grouped_list.append(orbs_projection_list[n_projection])
                    n_projection += 1
            orbs_projection_list = orbs_grouped_list
        else:
            pass
        assert len(orbs_projection_list)<4, 'ERROR: At this moment, orbs input supports only 3 orbitals.'
        
        orbs_colors = []
        for i in range(3):
            if len(orbs_colors)<len(orbs_projection_list):
                for j in range(len(orbs_projection_list[i])):
                    orbs_projection_list[i][j] = orbs_projection_list[i][j]
                orbs_colors.append(orbs_projection_list[i])
            else:
                orbs_colors.append([np.ones(len(orbs_colors[0][0])) for _ in range(len(orbs_colors[0]))])
        # -------------- isolates bands --------------
        if nbands is None:
            bands=E
        elif type(nbands) is int or type(nbands) is float:
            nbands = int(nbands)
            bands=E[0:nbands]
            new_colors = []
            for i in range(3):
                new_colors.append(orbs_colors[i][0:nbands])
            orbs_colors = new_colors
        elif type(nbands) is list:
            bands=[]
            new_colors = []
            for i in nbands:
                bands.append(E[int(i)])
            for i in range(3):
                for j in nbands:
                    new_colors.append(orbs_colors[i][int(j)])
            orbs_colors = new_colors
        else:
            print('ERROR: nbands must be an integer, a float or a list of integers.\n'+
                  'a '+str(type(nbands))+' type was recieved. Please check inputs.') 
            exit()
        # ---------- set colors --------------
        if colors!=[]:
            for i in range(len(colors)):
                    for j in range(len(colors[i])):
                        colors[i][j] = colors[i][j]/255
        else:
            colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        # -------------- plot bands --------------
        for i in range(3):
            for j in range(len(bands)):
                band=bands[j]-E_zero
                # color_projection = np.column_stack([orbs_color[0], orbs_color[1], orbs_color[2]]) 
                color_projection = np.column_stack([np.ones(len(orbs_colors[0][0]))*colors[i][0], np.ones(len(orbs_colors[0][0]))*colors[i][1], np.ones(len(orbs_colors[0][0]))*colors[i][2]])
                alpha = orbs_colors[i][j]
                # ---- create segments ----
                points = np.array([kpoints, band]).transpose().reshape(-1, 1, 2)
                segments = np.concatenate([points[:-1], points[1:]], axis=1)
                lc = LineCollection(segments, colors=color_projection, alpha=alpha, linewidths=self.main_linewidth)
    
                ax.add_collection(lc)

        # n = 0
        # for i in range(len(bands)):
        #     band=bands[i]-E_zero
        #     color_projection = [orbs_colors[0][i], orbs_colors[1][i], orbs_colors[2][i]]
        #     color_projection = np.array(color_projection).transpose()
        #     if n==0 and label is not None:
        #         n+=1
        #         ax.scatter(kpoints, band, s=1, c=color_projection, linewidth=self.main_linewidth, linestyle=self.main_linestyle, label=label)
        #     else:
        #         ax.scatter(kpoints, band, s=1, c=color_projection,  linewidth=self.main_linewidth, linestyle=self.main_linestyle)

        # ------------- set limits --------------
        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')

        # ------ output -------
        if label is not None:
            ax.legend()
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        return fig, ax

    def plot_bands_projected_orbs_3(self,
                           path_read,
                           root='PBAND_Atom1.dat',
                           orbs=[0, 1, 2],
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           colors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                           nbands=None,
                           ax=None,
                           show=False,
                           savefile=None):
        '''
        This function allows for the plotting of the band structure projected
        over atomic orbitals. Procesing of the data is required to be done by
        vaspkit1.3.5.
        At the moment, it can only plot one atom or element projection at a time.
        ==========
        Para orbs, se puede graficar por conjunto de orbitales. Por ejemplo, 
        S y P sería [[0], [1, 2, 3]]... 
        '''
        # -------------- reads info --------------
        orbs_grouped = False
        orbs_read = []
        n = 0
        for orb in orbs:
            if type(orb) is not float and type(orb) is not int:
                orbs_grouped = True
                n += 1 
                for i in orb:
                    orbs_read.append(i)
            else:
                orbs_read.append(orb)
        assert n < 4, 'ERROR: At this moment, orbs input supports only 3 orbitals (grouped orbitals count as 1).'

        if klabels is None and kticks is None:
            kpoints, E, orbs_projection_list, klabels, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read,fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=True)
        elif klabels is None and kticks is not None:
            kpoints, E, orbs_projection_list, klabels = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=True, kticks_bool=False)
        elif klabels is not None and kticks is None:
            kpoints, E, orbs_projection_list, kticks = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=True)
        else:
            kpoints, E, orbs_projection_list = self._read_bands_vaspkit_projected(path_read, root, orbs_read, fermi_vaspkit=E_vaspkit, klabels_bool=False, kticks_bool=False)
        # ------------ ax, fig objects -----------
        if ax is None and kbreaks is None:
            fig, ax = plt.subplots()
        elif ax is None and kbreaks is not None:
            num_ax = len(kbreaks)+1
            fig, ax = plt.subplots(num_ax)
        else:
            fig = ax.get_figure()
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ------- Order Projection and asign colors -------
        if orbs_grouped:
            orbs_grouped_list = []
            n_projection = 0
            for orb in orbs:
                if type(orb) is not float and type(orb) is not int:
                    orbs_sum = [np.zeros(len(orbs_projection_list[n_projection][0])) for _ in range(len(orbs_projection_list[n_projection]))]
                    for _ in range(len(orb)):
                        for band in range(len(orbs_sum)):
                            orbs_sum[band] += orbs_projection_list[n_projection][band]                  
                        n_projection += 1
                    orbs_grouped_list.append(orbs_sum)
                else:
                    orbs_grouped_list.append(orbs_projection_list[n_projection])
                    n_projection += 1
            orbs_projection_list = orbs_grouped_list
        else:
            pass
        assert len(orbs_projection_list)<4, 'ERROR: At this moment, orbs input supports only 3 orbitals.'
        
        orbs_colors = []
        for i in range(3):
            if len(orbs_colors)<len(orbs_projection_list):
                for j in range(len(orbs_projection_list[i])):
                    orbs_projection_list[i][j] = orbs_projection_list[i][j]
                orbs_colors.append(orbs_projection_list[i])
            else:
                orbs_colors.append([np.ones(len(orbs_colors[0][0])) for _ in range(len(orbs_colors[0]))])
        # ----- change to arbitrary colors -----
        if colors!=[]:
            # change rgb into 0-1 scale
            for i in range(len(colors)):
                for j in range(len(colors[i])):
                    colors[i][j] = colors[i][j]/255
            # check that 3 colors are given
            assert len(colors)==3, 'ERROR: colors must be a list of 3 lists of 3 integers.'
        # -------------- isolates bands --------------
        if nbands is None:
            bands=E
        elif type(nbands) is int or type(nbands) is float:
            nbands = int(nbands)
            bands=E[0:nbands]
            new_colors = []
            for i in range(3):
                new_colors.append(orbs_colors[i][0:nbands])
            orbs_colors = new_colors
        elif type(nbands) is list:
            bands=[]
            new_colors = []
            for i in nbands:
                bands.append(E[int(i)])
            for i in range(3):
                for j in nbands:
                    new_colors.append(orbs_colors[i][int(j)])
            orbs_colors = new_colors
        else:
            print('ERROR: nbands must be an integer, a float or a list of integers.\n'+
                  'a '+str(type(nbands))+' type was recieved. Please check inputs.') 
            exit()
        # -------------- plot bands --------------
        # for band, orbs_color in zip(bands, orbs_colors):
        #     band-=E_zero
        #     color_projection = np.column_stack([orbs_color[0], orbs_color[1], orbs_color[2]]) 
        #     # ---- create segments ----
            

        # n = 0
        # for i in [1, 0]:
        #     for j in range(len(bands)):
        #         band=bands[j]-E_zero
        #         size = 1 # (orbs_colors[i][j]*100)
        #         alpha = (orbs_colors[i][j]/max(orbs_colors[i][j]))
        #         # color_projection = np.array(color_projection).transpose()
        #         if n==0 and label is not None:
        #             n+=1
        #             ax.plot(kpoints, band, s=size, c=colors[i], alpha=alpha,  linewidth=self.main_linewidth, linestyle=self.main_linestyle, label=label)
        #         else:
        #             ax.plot(kpoints, band, s=size, c=colors[i], alpha=alpha,  linewidth=self.main_linewidth, linestyle=self.main_linestyle)

        # ------------- set limits --------------
        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')

        # ------ output -------
        if label is not None:
            ax.legend()
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        return fig, ax

    def plot_bands_projected_orbs_p4vasp(self,
                           path_read,
                           root='PBAND_Atom1.dat',
                           norbs=None,
                           E_limit=[-1, 1],
                           E_zero=0,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           colors=[[255, 0, 0], [0, 255, 0], [0, 0, 255]],
                           nbands=None,
                           ax=None,
                           show=False,
                           savefile=None):
        # -------------- reads info --------------
        if klabels is None and kticks is None:
            kpoints, bands, bands_projections, klabel, kticks = self._read_bands_p4vasp_projected(path_read, root, norbs, klabels_bool=True, kticks_bool=True)
        elif klabels is None and kticks is not None:
            kpoints, bands, bands_projections, klabel = self._read_bands_p4vasp_projected(path_read, root, norbs, klabels_bool=True, kticks_bool=False)
        elif klabels is not None and kticks is None:
            kpoints, bands, bands_projections, kticks = self._read_bands_p4vasp_projected(path_read, root, norbs, klabels_bool=False, kticks_bool=True)
        else:
            kpoints, bands, bands_projections = self._read_bands_p4vasp_projected(path_read, root, norbs, klabels_bool=False, kticks_bool=False)
        # ------------ ax, fig objects -----------
        if ax is None and kbreaks is None:
            fig, ax = plt.subplots()
        elif ax is None and kbreaks is not None:
            num_ax = len(kbreaks)+1
            fig, ax = plt.subplots(num_ax)
        else:
            fig = None
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
        # ------- Order Projection and asign colors -------
        # --- define colors ---
        for i in range(len(colors)):
            for j in range(len(colors[i])):
                colors[i][j] = colors[i][j]/255
            colors[i] = np.array(colors[i])
        # ---- checks that there are 3 list of projections ----
        print(f'There are {len(bands)} bands. The number of projections is: ', len(bands_projections))
        while len(bands_projections)<3:
            bands_projections.append(np.zeros(np.shape(bands_projections[0])))
        # la proyeccion es de la forma 3 proyecciones x nbandas x nkpoints. Para pasar
        # esto a color, la lista pasa a ser nbandas x 3 colores x nkpoints
        colors_projections = np.empty((len(bands), 3, len(kpoints))) 
        # i es la banda, j es la componente del color, k es el punto k...
        l = []
        for i in range(len(bands)):
            for j in range(3):
                for k in range(len(kpoints)):
                    # promedio ponderado
                    colors_projections[i][j][k] = 1 - (bands_projections[0][i][k]*(1-colors[0][j]) + bands_projections[1][i][k]*(1-colors[1][j]) + bands_projections[2][i][k]*(1-colors[2][j])) #/(colors[0][j]+colors[1][j]+colors[2][j])
                    # Checks for saturated values
                    if colors_projections[i][j][k]>1:
                        colors_projections[i][j][k] = 1
                    elif colors_projections[i][j][k]<0:
                        colors_projections[i][j][k] = 0                    
        # ----------- plot projected bands ------------
        for band, colors in zip(bands, colors_projections):
            # ------- asign colors -------
            band-=E_zero
            color_projection = np.column_stack([colors[0], colors[1], colors[2]])
            # ---- create segments ----
            points = np.array([kpoints, band]).transpose().reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            lc = LineCollection(segments, colors=color_projection, linewidths=self.main_linewidth)
 
            ax.add_collection(lc)
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ---------- set limits and ylabel ----------
        bool_klabels = [i=='' for i in klabels]
        klabels_filtered = [i for i in klabels if i!='']
        if any(bool_klabels):
            if len(klabels_filtered)!=2:
                ind = klabels.index('')
                ax.set_xlim([0,kticks[ind-1]])
            elif len(klabels_filtered)==2:
                ind1 = klabels.index(klabels_filtered[0])
                ind2 = klabels.index(klabels_filtered[1])
                ax.set_xlim([kticks[ind1],kticks[ind2]])
        else:
            ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')
        # ------ output -------
        if label is not None:
            ax.legend()
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        
        return ax.figure, ax

    def plot_pathIntensity(self,
                           path_read,
                           bands,
                           intensity,
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           color='k',
                           ax=None,
                           show=False,
                           savefile=None
                           ):
        '''
        IN DEVELOPEMENT
        '''
        # ------- some parameters -------
        kwidth = 0.2 
        # ======== read data ========
        bands = np.loadtxt(open(path_read + "/bandsWannierBerri.dat","r"))
        curv = np.loadtxt(open(path_read + '/curvatureWannierBerri.dat',"r"))
        kticksAndLabel = np.loadtxt(open(path_read + '/kticks.dat',"r"), str)

        kpoints = np.transpose(bands)[0]
        bands = np.transpose(bands)[1:]
        curv = np.transpose(curv)[1:]
        kticks = np.array(([float(i) for i in np.transpose(kticksAndLabel)[0]]))
        if klabels==[]:
            klabels = np.transpose(kticksAndLabel)[1]
        # ====== organize data ======
                           
    def plot_AHC_wannierberri(self,
                           path_read,
                           ahc_axis='all',
                           E_limit=None,
                           ahc_limit=None,
                           E_zero=0,
                           norm_val=1,
                           colors=None,
                           spin='both',
                           root='AHC',
                           iteration=[1],
                           fig_orientation='vertical',
                           scale='linear',
                           ax=None,
                           show=False,
                           savefile=None):
        # ---------------- alert ----------------
        print('------------------------------------------')
        print('WARNING: wannierberri changes the UNITS of\nAHC depending on the version used to run\nthe calculation. Please check them.')
        print('------------------------------------------')
        # ----------- fig, ax objects -----------
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.get_figure()
        if colors is not None:
            ax.set_prop_cycle('color', colors)  # Colores a usar
        # --------- read data ----------
        ahc_data = [np.loadtxt(path_read+'/'+root+f"-ahc_iter-{i:04d}.dat") for i in iteration]
        # ----- ahc axis selection -----
        if ahc_axis=='all':
            ahc_label =fr'$\sigma [S/cm]$'
            if spin=='both':
                curv_label = [r'$\sigma_{yz}$ - down', r'$\sigma_{yz}$ - up', r'$\sigma_{xz}$ - down',
                              r'$\sigma_{xz}$ - up', r'$\sigma_{xy}$ - down', r'$\sigma_{xy}$ - up']
            if spin=='up':
                curv_label = [r'$\sigma_{yz}$ - up', r'$\sigma_{xz}$ - up', r'$\sigma_{xy}$ - up']
            if spin=='down':
                curv_label = [r'$\sigma_{yz}$ - down', r'$\sigma_{xz}$ - down', r'$\sigma_{xy}$ - down']
        else:    
            ahc_label=fr'$\sigma_{ahc_axis} [S/cm]$'
        # --------- orientation ---------
        if (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
            ax.set_xlabel(ahc_label)
            if fig_orientation=='vertical_rigth'or'vr':
                ax.yaxis.set_label_position("right")
                ax.yaxis.tick_right()
            ax.set_ylabel(fr'$E-E_F$ [eV]')
            ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
            ax.set_xscale(scale)
        elif (fig_orientation=='horizontal'or'h'):
            ax.set_ylabel(ahc_label)
            ax.set_xlabel(fr'$E-E_F$ [eV]')
            ax.axvline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
            ax.set_yscale(scale)
        # --------- plotting ---------
        if ahc_axis=='all':
            n=0
            for x in range(3):
                for i in range(len(ahc_data)):
                    a=ahc_data[i]
                    E=a[:,0]
                    if x==0:
                        E-=E_zero
                    AHC_down=a[:,x+1]
                    AHC_up  =a[:,x+1+3]
                    # ----- curv -----
                    if (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
                        if spin=='both':
                            ax.plot(AHC_down/norm_val, E, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                            n+=1
                            ax.plot(AHC_up/norm_val, E, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        elif spin=='up':
                            ax.plot(AHC_up/norm_val, E, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        elif spin=='down':
                            ax.plot(AHC_down/norm_val, E, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)  
                    elif (fig_orientation=='horizontal'or'h'):
                        if spin=='both':
                            ax.plot(E, AHC_down/norm_val, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                            n+=1
                            ax.plot(E, AHC_up/norm_val, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        elif spin=='up':
                            ax.plot(E, AHC_up/norm_val, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        elif spin=='down':
                            ax.plot(E, AHC_down/norm_val, label=curv_label[n], linewidth=self.main_linewidth, linestyle=self.main_linestyle)  
        else:
            for i in range(len(ahc_data)):
                a=ahc_data[i]
                E=a[:,0]
                E-=E_zero
                AHC_down=a[:,x+1]
                AHC_up  =a[:,x+1+3]
                # ----- curv -----
                if (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
                    if spin=='both':
                        ax.plot(AHC_down, E, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        ax.plot(AHC_up, E, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif spin=='up':
                        ax.plot(AHC_up, E, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif spin=='down':
                        ax.plot(AHC_down, E, linewidth=self.main_linewidth, linestyle=self.main_linestyle)  
                elif (fig_orientation=='horizontal'or'h'):
                    if spin=='both':
                        ax.plot(E, AHC_down, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                        ax.plot(E, AHC_up, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif spin=='up':
                        ax.plot(E, AHC_up, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif spin=='down':
                        ax.plot(E, AHC_down, linewidth=self.main_linewidth, linestyle=self.main_linestyle)  
        # -------- legend ---------
        ax.legend(loc='best')
        # -------- set limits --------
        if ahc_limit is not None and (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
            ax.set_xlim(ahc_limit)
        elif ahc_limit is not None and (fig_orientation=='horizontal'or'h'):
            ax.set_ylim(ahc_limit)
        
        if E_limit is not None and (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
            ax.set_ylim(E_limit)
        elif E_limit is None and (fig_orientation=='vertical'or'v'or'vertical_rigth'or'vr'):
            ax.set_ylim([min(E), max(E)])
        elif E_limit is not None and (fig_orientation=='horizontal'or'h'):
            ax.set_xlim(E_limit)
        elif E_limit is None and (fig_orientation=='horizontal'or'h'):
            ax.set_xlim([min(E), max(E)])

        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')

        return fig, ax    
    
    def plot_xy():
        # look script 'plot_curvature.py' or 'plot_AHC.py'
        pass

    def plot_grid():
        # For plotting Curvature on surface. 
        pass

    def plot_LDoS(self, 
                  path_read,
                  program='vaspkit',
                  root=None,
                  orbitals_tag='all',
                  colors=None,
                  E_limit=None,
                  DOS_limit=None,
                  E_zero=0,
                  E_vaspkit=False,
                  axes_vertical=False,
                  ax=None,
                  show=False,
                  savefile=None):
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.get_figure()
        if colors is not None:
            ax.set_prop_cycle('color', colors)  # Colores a usar
        # --------- read data ---------
        path = f'{path_read}/{root}'
        if program=='vaspkit':
            E, orbitals_labels, orbitals, total = self._read_LDoS_vaspkit(path, E_vaspkit)
        elif program=='p4vasp':
            E, orbitals, total = self._read_LDoS_p4vasp(path, E_vaspkit)
        # ----- Sets zero energy level -----
        E -= E_zero
        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # --------- plot partial DOS ---------
        if program=='vaspkit':
            if orbitals_tag=='all':
                for orbs, label in zip(orbitals, orbitals_labels):
                    if axes_vertical==False:
                        ax.plot(E, orbs, label=label, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif axes_vertical==True:
                        ax.plot(orbs, E, label=label, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
            else:
                for tag in orbitals_tag:
                    index = orbitals_labels.index(tag)
                    if axes_vertical==False:
                        ax.plot(E, orbitals[index], label=tag, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                    elif axes_vertical==True:
                        ax.plot(orbitals[index], E, label=tag, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
        elif program=='p4vasp':
            for orb, tag_orb in zip(orbitals, orbitals_tag):
                if axes_vertical==False:
                    ax.plot(E, orb, label=tag_orb, linewidth=self.main_linewidth, linestyle=self.main_linestyle)
                elif axes_vertical==True:
                    ax.plot(orb, E, label=tag_orb, linewidth=self.main_linewidth, linestyle=self.main_linestyle)            
        # --------- plot total DOS ---------
        if axes_vertical==False:
            ax.plot(E, total, color='gray', linewidth=self.main_linewidth*0.8, linestyle='--')
            ax.set_xlabel('Energy [eV]')
            ax.set_ylabel('DOS [states/eV]')
            if E_limit is not None:
                ax.set_xlim(E_limit)
            else:
                ax.set_xlim([min(E), max(E)])
            if DOS_limit is not None:
                ax.set_ylim(DOS_limit)
        elif axes_vertical==True:
            ax.plot(total, E, color='gray', linewidth=self.main_linewidth*0.8, linestyle='--')
            ax.set_ylabel('Energy [eV]')
            ax.set_xlabel('DOS [states/eV]')
            if E_limit is not None:
                ax.set_ylim(E_limit)
            else:
                ax.set_ylim([min(E), max(E)])
            if DOS_limit is not None:
                ax.set_xlim(DOS_limit)

        ax.legend()
        # if tag_bool and not DOS_total:
        #     ax.set_title('Right-click to hide all\nMiddle-click to show all',
        #             loc='right')  # , size='medium')
        #     ax.legend(loc='upper left', bbox_to_anchor=(1.05, 1),
        #             ncol=3)
        #     leg = interactive_legend()
        #     fig.subplots_adjust(right=0.55)
        
        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        return fig, ax

    def plot_curvature_path(self,
                            path_read,
                            axis=0,
                            kticks=None,
                            klabels=None,
                            kbreaks=None,
                            colors=['r', 'g', 'b'],
                            curv_limit=None,
                            ax=None,
                            show=False,
                            savefile=None):
        # ------------ ax, fig objects -----------
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.get_figure()
        # -------- axis name --------
        if int(axis) == 0:
            axisName = ''
        elif int(axis) == 1:
            axisName = '_x'
        elif int(axis) == 2:
            axisName = '_y'
        elif int(axis) == 3:
            axisName = '_z'
        # ---- E Zero ----
        ax.axhline(0, color=self.E_zero_color, linewidth=self.E_zero_linewidth, linestyle=self.E_zero_linestyle)
        # ---- kpoints ---
        if kticks is not None:
            for i in range(len(kticks)):
                if kbreaks is not None:
                    if i in kbreaks:
                        ax.axvline(kticks[i], color='k', linewidth=self.k_linewidth*1.8, linestyle=self.k_linestyle)    
                    else:
                        ax.axvline(kticks[i], color=self.k_color, linewidth=self.k_linewidth, linestyle=self.k_linestyle)    
        # ---- klabels ---
        if klabels is not None:
            ax.set_xticks(kticks,klabels)

        # ----- curv -----
        if axis==0:
            curvLabel = [r'$\Omega_x$', r'$\Omega_y$', r'$\Omega_z$']
            for i in [1, 2, 3]:
                # -------------- reads info --------------
                kpoints, curv = self._read_curvature_wannier90(path_read, i)
                # ----- plot -----
                ax.plot(kpoints, curv, color=colors[i-1], label=curvLabel[i-1], linewidth=self.main_linewidth, linestyle=self.main_linestyle)        
                # ----------------
        else:
            # -------------- reads info --------------
            kpoints, curv = self._read_curvature_wannier90(path_read, axis)    
            # ----- plot -----
            ax.plot(kpoints, curv, color=colors[0], linewidth=self.main_linewidth, linestyle=self.main_linestyle)
            # ----------------
        
        ax.legend(loc='best')

        # ------- Cut unnamed paths and axis limits-------
        boolKnames = [i=='' for i in klabels]
        knamesFiltered = [i for i in klabels if i!='']
        if any(boolKnames):
            if len(knamesFiltered)!=2:
                ind = klabels.index('')
                ax.set_xlim([0,kticks[ind-1]])
            elif len(knamesFiltered)==2:
                ind1 = klabels.index(knamesFiltered[0])
                ind2 = klabels.index(knamesFiltered[1])
                ax.set_xlim([kticks[ind1],kticks[ind2]])
        else:
            ax.set_xlim([kticks[0],kticks[-1]])

        if curv_limit is not None:
            ax.set_ylim(curv_limit)
        else:
            # ylimit = [min(curv)-0.025*(max(y)-min(y)),max(y)+0.025*(max(y)-min(y))]
            # ax.set_ylim(ylimit)
            pass
        # ----- set labels -----
        kBold = r'\mathbf{k}'
        ax.set_ylabel(fr'$-\Omega{axisName}({kBold})$  [ $\AA^2$ ]')

        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile, bbox_inches='tight')
        return fig, ax